fn main() {
    let s1 = "S((SS)X)YZ".to_string();
    //let a = next_term(s1);
    //let b = next_term(a.clone().unwrap().1);
   
    //dbg!(a, b);
}


enum Op {
    S,
    K,
    I,
    None
}

// fn get_next_n(s: String, n: usize) -> Vec<String> {
//     if n <= 0 {
//         vec![]
//     } else {
//         let (a, b) = next_term(s)
//     }
// }

// Search for S, K, I, and evaluate the first one found
// If normal form, do nothing to the string
fn eval_one_step(s: String) -> String {
    let mut before = "".to_string();
    let mut after = "".to_string();
    let mut found_eval = false;
    let mut op = Op::None;
   
    // This is a really jank way to make two strings split at the first
    // S, K, or I
    for c in s.chars() {
        match found_eval {
            false => {
                match c {
                    'S' => { op = Op::S; found_eval = true; },
                    'K' => { op = Op::K; found_eval = true; },
                    'I' => { op = Op::I; found_eval = true; },
                    a => { before.push(a) },
                };
            },
            true => {
                after.push(c);
            }
        }
    };
   
    after + &before
   
}

// Returns the next term of a given string
// If it is a char, return the char
// If it is an open paren, return the string between the first paren and the last
// If there are no more terms, return none
// Otherwise, panic
fn next_term(s: String) -> (String, Option<String>) {
    match s.chars().next() {
        Some(x => match x {
            '(' => here_to_next_paren(s),
            ')' => panic!("Extra close paren"),
           
            // Note that this allows too many characters, like [ to be used
            'A'..='z' => (s.chars().next().unwrap().to_string(),
                                 Some(s.chars().skip(1).collect())),
            _  => panic!("Invalid character"),
        }
        None => None,
    }
}


fn here_to_next_paren(s: String) -> (String, Option<String>) {
    let mut stack: usize = 1; // open - close -- greater than 0 or panic
    let mut in_parens = "".to_string();
    let mut out_of_parens = "".to_string();
    let mut found = false;
    //dbg!(s);
   
    // Skip first paren
    for c in s.chars().skip(1) {
        if stack > 0 && !found {
            match c {
                '(' => { stack = stack + 1; in_parens += &c.to_string(); },
                ')' => { stack = stack - 1; in_parens += &c.to_string(); },
                'A'..='z' => { in_parens += &c.to_string(); },
                _ => panic!("Invalid character in next_paren"),
            }
        } else {
            found = true;
            out_of_parens += &c.to_string();
        }
    };
    // Jankest possibile way to skip the last char
    in_parens = in_parens.chars().rev().skip(1).collect::<String>().chars().rev().collect();
    (in_parens, if found { Some(out_of_parens) } else { None } )
}


